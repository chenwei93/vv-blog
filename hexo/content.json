[{"title":"2018-1-16-演习","date":"2018-01-16T03:01:25.000Z","path":"2018/01/16/2018-1-16-演习/","text":"请注意，这只是个演习。","tags":[]},{"title":"vue-about","date":"2017-11-17T06:30:23.000Z","path":"2017/11/17/2017-11-17-vue-about/","text":"VUE-ABOUT .vue中 scope的实现vue文件可以实现当前文件的css作用域实现手法是通过vue-loader后生成一个随机字符串属性 通过内置css属性选择器实现like that123456789101112131415&lt;template&gt; &lt;div class=\"scope-div\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;style scope&gt; .scope-div&#123; width: 200px; &#125;&lt;/style&gt;&lt;!--打包处理后--&gt;&lt;style&gt; .scope-div[data-v-7af99ee4]&#123; width: 200px; &#125;&lt;/style&gt;&lt;div class=\"scope-div\" data-v-7af99ee4&gt;&lt;/div&gt; VuexVuex 中模块的划分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import mutations from './mutations'import actions from './actions'import ware from './module/wareModule'const store = new Vuex.Store(&#123; state: &#123; viewImageConfig:&#123; isShow:false, url:'' &#125; &#125;, mutations, // 修改store方法 actions, // 调用修改store方法 modules: &#123; ware &#125;,&#125;)//actions.jsexport default &#123; demoAction(&#123;commit&#125;)&#123; &#125;&#125;//ware.jsconst state = &#123; demoWareStore:'345'&#125;const getters = &#123; getDemoWareStore: state =&gt; state.demoWareStore&#125;const actions = &#123; demoWareAction(&#123;commit,state&#125;,rs)&#123; console.log(rs) commit('DEMO_WARE_MUT',rs) &#125;&#125;const mutations = &#123; DEMO_WARE_MUT(state,rs)&#123; console.log(rs) state.demoWareStore = '123' &#125;&#125;export default &#123; state, getters, actions, mutations&#125; vuex 实例会混入vue的实例中通过this.$store而模块中引入的 action mutations getters 都会和全局混合在一起this.$store._actions[demoWareAction,demoAction]而state会根据module分割this.$store.store.viewImageConfigthis.$store.store.ware.demoWareStore Vue中路由 层级的渲染首先Router和route 会混入到vue的实例中去vue-router 提供了 一个 router-view 的组件如果是嵌套的路由 vue-router 是怎么实现对应的显示首先在 在显示 当前组件时 vue-router 会根据当前路由生成一个 已经匹配过的数组12345678910111213141516$route = &#123; path:'/part', matched:[ &#123; path:'', name:'Home', ... &#125;, &#123; path:'/part', name:'Part', ... &#125;, ], ...&#125; 渲染 vue-router 时 会去判断 当前组件的层级然后对应去 这个 matched 中取层级下标对应的值1234567891011121314const route = parent.$routelet depth = 0let inactive = falsewhile (parent &amp;&amp; parent._routerRoot !== parent) &#123; if (parent.$vnode &amp;&amp; parent.$vnode.data.routerView) &#123; depth++ &#125; if (parent._inactive) &#123; inactive = true &#125; parent = parent.$parent &#125; const matched = route.matched[depth] //此时mathed 就是匹配到要渲染的 组件 举例说明路由配置如下1234567891011121314151617const router = new Router(&#123; routes:[ &#123; path: '/', name: 'Home', component: Home, children: [ &#123; path: '/part', name: 'Part', component: Part, &#125; ] &#125; ]&#125;) 123456789101112131415161718192021222324&lt;!--App--&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;!--Home--&gt;&lt;template&gt; &lt;div v-if=\"readyMenu\"&gt; &lt;v-head /&gt; &lt;v-menu&gt;&lt;/v-menu&gt; &lt;div class=\"content-box\"&gt; &lt;transition name=\"move\" mode=\"out-in\"&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; &lt;/div&gt; &lt;v-load /&gt; &lt;v-toast /&gt; &lt;/div&gt;&lt;/template&gt;&lt;!--Part--&gt;&lt;template&gt; &lt;div&gt; Part &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536// 路由为 localhost:8010/#/时 $route = &#123; path:'/', matched:[ &#123; path:'', name:'Home', ... &#125; ], ...&#125;// 此时depth = 0const matched = route.matched[depth]// 路由为 localhost:8010/#/part时 $route = &#123; path:'/part', matched:[ &#123; path:'', name:'Home', ... &#125;, &#123; path:'', name:'Part', ... &#125; ], ...&#125;//先渲染Home之后depth = 1const matched = route.matched[depth]","tags":[{"name":"vue","slug":"vue","permalink":"//vivi.fenghou.site/tags/vue/"}]},{"title":"css-Box-Model","date":"2017-11-07T01:56:43.000Z","path":"2017/11/07/2017-11-07-css-box-model/","text":"css-box 总结 盒模型的计算盒模型 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式 盒模型 宽高的计算box-sizing 属性可以通俗的理解为 给box设置的宽高从哪里开始计算盒模型的真实宽高 = border-box + padding-box + content-box box-sizing: content-box(标准盒模型) 表示设置的宽高是 content-box的宽高 那渲染在页面上真实的宽高还要加上 padding-box 和 border-boxwidth(真实) = width(content-box设置的width) + padding-box + border-box box-sizing: border-box(IE盒模型) 表示设置的宽高是 border-box的宽高 那渲染在页面上真实的宽高就是 设置的宽高width(真实) = width(设置的width) box-sizing: inherit 从父元素继承 BFC &amp;&amp; IFCBFC 块级格式化上下文可以通过构建BFC 解决margin 重合 清除浮动float的值不为noneposition的值不为static或者relativedisplay的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个overflow的值不为visible IFC 内联格式化上下文默认对齐方式 vertical-align:baseline 所以同时存在有内容的内联元素和没内容的内联元素 有内容的 会往下掉vertical-align:top 背景的起始background-clip 表示背景在盒模型中显示的位置border-box 从border-box开始有背景padding-box 从padding-box开始有背景content-box 从content-box开始有背景background-origin 表示背景在盒模型中开始渲染的位置border-box 背景从border-box 处开始渲染padding-box 背景从padding-box 处开始渲染content-box 背景从content-box 处开始渲染 background-position 表示从这张背景图片的什么位置 开始渲染在 元素背景上background-position:X% Y%(百分比值) 表示会把图片 横向X% 纵向的Y% 的点与 元素 横向X% 纵向的Y%点对齐background-position:Xpx Ypx(数值) 表示图片距离背景起始绘制点的距离 background-position: /","tags":[{"name":"css","slug":"css","permalink":"//vivi.fenghou.site/tags/css/"}]},{"title":"浏览器中js事件运行机制","date":"2017-08-08T08:28:27.000Z","path":"2017/08/08/2017-08-08-js-event-loop/","text":"总结一下 浏览器中js事件运行机制起因是女票今天问我一个问题问题如下 alert引起的争论123456789101112var count = 0, domProcess = document.querySelector('#process'), inter = nullinter = setInterval(function()&#123; if(count == 100)&#123; domProcess.innerText = count+'%' console.log(count) alert('加载完成') clearInterval(inter) &#125;&#125;,100)//弹框时 为什么页面上process显示的是99%？ 因为前段时间了解过Event-Loop的机制 知道怎么去解决它但是要跟女票讲清楚 还是得在总结总结 毕竟自己也是了解的不深 单线程 &amp;&amp; 任务队列 &amp;&amp; Event-Loop 图片来自Philip Roberts的演讲《Help, I’m stuck in an event-loop》Help, I’m stuck in an event-loop优酷地址 首先Js是单线程的 异步是浏览器的事(宿主环境)主线程运行的时候 产生堆(heap)和栈(stack)主线程将运行中碰到的事件推入 执行栈中 开始执行执行结束后 弹出执行栈 推入下一个事件当执行到webAPI时 会将它当做任务源(相当于是分发任务)来执行 并且弹出这时候会产生一个待执行的任务当这个任务满足执行条件时 会进入到任务队列当中当执行栈 为空时 主线程会不断的去调取任务队列中任务 推入 执行栈中执行 这个运行机制就是 Event-Loop而任务队列 可以分为 宏任务队列(macro-task) 和 微任务队列(micro-task)当执行栈为空时 主线程会先去micro-task中调取任务 micro-task为空时才会去 macro-task调取任务执行 触发任务的webAPIDOM(DOCUMENT),AJAX,setTimeOut,setInterval,Promise,process.nextTick,setImmediate其中 加入宏队列中任务 DOM(DOCUMENT),AJAX,setTimeOut,setInterval,setImmediate加入微任务队列中的任务 Promise,process.nextTick 真相所以 上面的js在执行中遇到 document.querySelector(&#39;#process&#39;).innerText = count+&#39;%&#39;推入执行栈 由于是DOM操作判定为任务源 推出执行栈满足执行条件 加入到 宏任务队列遇到 console.log(count)推入执行栈 控制台输出 100 推出执行栈遇到 alert(&#39;加载完成&#39;)推入执行栈 开始执行 主线程挂起 等待弹框确认弹窗确认后 推出执行栈遇到 clearInterval(inter)推入执行栈 执行 推出执行栈此时执行栈为空 开始调用 任务队列微任务队列为空 直接调用宏任务队列将 document.querySelector(&#39;#process&#39;).innerText = count+&#39;%&#39; dom操作分发的执行任务推入执行栈渲染页面数据 推出执行栈 所以要解决这个问题 只需要加个setTimeout就能解决问题123setTimeout(function()&#123; alert('加载完成') &#125;,0) 这里有个问题就是 碰到这个webAPI时 并不是把 这些webAPI推入任务队列在执行栈中 这些webAPI还是立即执行的 是把它分发的任务 推入任务队列1234567//譬如setTimeout(function()&#123; console.log('log')&#125;,1000)//setTimeOut 会立即进入执行栈 并且执行//它的第一个参数就是他要分发的任务 会在满足它的分发条件后进入任务队列 // 上例就是1000ms后进入任务队列 再看下面的两个例子123456789101112131415161718192021222324252627282930313233//demo 1setTimeout(function A() &#123; setTimeout(function B()&#123;console.log(8);&#125;,0); console.log(5); Promise.resolve().then(()=&gt;&#123; console.log(7); &#125;) console.log(6)&#125;,0);console.log(1)new Promise(function(reslove)&#123; console.log(2); reslove()&#125;).then(()=&gt;&#123; console.log(4)&#125;)console.log(3)//demo 2function A(x)&#123; setTimeout(function()&#123; console.log(2.2+x) &#125;,0) Promise.resolve().then(()=&gt;&#123; console.log(2.1+x); &#125;) console.log(1+x)&#125;function B()&#123; A('B')&#125;A('A')B() 联系上面的分析第一题的输出 应该是 1 2 3 4 5 6 7 8 第二题的输出 应该是 1A 1B 2.1A 2.1B 2.2A 2.2B 写在一块输出 应该是 1 2 1A 1B 3 4 2.1A 2.1B 5 6 7 2.2A 2.2B 8 参考文章js的单线程和异步JavaScript 运行机制详解：再谈Event Loop前端基础进阶（十二）：深入核心，详解事件循环机制","tags":[{"name":"js","slug":"js","permalink":"//vivi.fenghou.site/tags/js/"}]},{"title":"Vue事件","date":"2017-07-20T02:18:56.000Z","path":"2017/07/20/2017-07-20-vue-event/","text":"vue 中通过[$on]注册事件[$emit]来触发事件这里来模拟一下它内部的实现机制超简易 初始化Vue123456789function V()&#123; this._init()&#125;function initMixin(v)&#123; v.prototype._init = function()&#123; initEvent(this) &#125;&#125;initMixin(V) 初始化事件123function initEvent(v)&#123; v._events = Object.create(null)&#125; 混合事件123456789101112131415161718192021function eventsMixin(v)&#123; v.prototype.$on = function(name,fn)&#123; this._events[name] = fn &#125; v.prototype.$emit = function(event)&#123; let cbs = this._events[event] let args = toArray(arguments,1) cbs.apply(this,args) &#125;&#125;eventsMixin(V)function toArray (list, start) &#123; start = start || 0 let i = list.length - start const ret = new Array(i) while (i--) &#123; ret[i] = list[i + start] &#125; return ret&#125; 调用12345var v = new V()v.$on('click',function(msg)&#123; console.log(msg)&#125;)v.$emit('click','emit')","tags":[{"name":"js","slug":"js","permalink":"//vivi.fenghou.site/tags/js/"},{"name":"vue","slug":"vue","permalink":"//vivi.fenghou.site/tags/vue/"}]},{"title":"谈谈js的继承","date":"2017-01-03T11:11:44.000Z","path":"2017/01/03/2017-01-03-谈谈js的继承/","text":"继承在JavaScript中不像在别的面向对象语言中那样简单JavaScript使用的是基于对象的继承它可以用来模仿基于类的继承Es6中，新增了Class和extends关键字来支持类的继承在这里记录各种继承的实现方式 类式继承JavaScript对象可以模仿Java中的对象通过函数来声明类用关键字new来创建实例这种方式包括两个步骤1.用一个类的声明定义对象的结构2.实例化该类创建一个新对象123456789//类的实例function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(this.sName);&#125;;var Ls = new Person('Ls');Ls.sayName(); 这种类式继承的方式可以分为五种对象冒充，Call，Apply，原型链和混合模式 对象冒充构造函数使用 this 关键字给所有属性和方法赋值因为构造函数只是一个函数所以可使Person构造函数成为Author的方法，然后调用它Author就会收到Person的构造函数中定义的属性和方法123456789101112131415161718function Person(name)&#123; this.name = name; this.sayName=function()&#123; console.log(this.name); &#125; &#125;function Author(name,book)&#123; this.book = book; this.Person = Person; this.Person(name); delete this.Person; this.sayBook = function()&#123; console.log(this.book) &#125;&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook(); apply&amp;&amp;call继承call和apply方法通过改变函数上下文实现继承1234567891011121314151617function Person(name)&#123; this.name = name; this.sayName=function()&#123; console.log(this.name); &#125; &#125;function Author(name,book)&#123; this.book = book; Person.call(this,name); Person.apply(this,[name]); this.sayBook = function()&#123; console.log(this.book) &#125;&#125;var Ls = new Author('Ls','My Book'); Ls.sayName(); Ls.sayBook(); 原型链使子类原型对象指向父类的实例以实现继承,即重写类的原型对象1234567891011121314151617function Person()&#123;&#125;Person.prototype.sName = '';Person.prototype.sayName = function () &#123; console.log(this.sName);&#125;;function Author(book)&#123; this.book = book;&#125;Author.prototype = new Person();Author.prototype.sayBook= function()&#123; console.log(this.book);&#125;;var Ls = new Author('My book');Ls.sName = 'Ls';Ls.sayName();Ls.sayBook(); 这种模式无法使用带参数的构造函数，不支持多重继承 混合模式继承用对象冒充继承构造函数的属性，用原型链继承 prototype 对象的方法123456789101112131415161718function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(this.name);&#125;;function Author(name,book)&#123; Person.call(this,name); this.book = book;&#125;Author.prototype = new Person();Author.prototype.constructor = Author;Author.prototype.sayBook = function()&#123; console.log(this.book);&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook(); 为了简化类的声明，可以把派生子类的整个过程包装在一个名为extend的函数中空函数F，这样可以避免创建Person的新实例,因为它可能会比较庞大增加superclass这个属性弱化Author与Person之间的耦合并且确保constructor属性被正确设置123456789101112131415161718192021222324252627function extend(subClass.superClass)&#123; var F = function()&#123;&#125;; F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass; subClass.superclass = superClass.prototype; if(subClass.prototype.constructor == Object.prototype.constructor)&#123; subClass.prototype.constructor = subClass; &#125;&#125;function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(this.name);&#125;;function Author(name,book)&#123; Author.superclass.constructor.call(this,name); this.book = book;&#125;extend(Author,Person)Author.prototype.sayBook = function()&#123; console.log(this.book);&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook(); JavaScript中的类式继承仅仅是对正正基于类的继承的一种模仿 原型式继承原型式继承与类式继承截然不同它并不需要用类来定义对象结构，只需要创建一个对象这个对象可以被新的对象重用1234567891011121314151617181920212223var Person = &#123; name:'default name', sayName:function()&#123; console.log(this.name); &#125;&#125;var Author = clone(Person);Author.book = 'default book';Author.sayBook = function()&#123; console.log(this.book);&#125;var Ls = clone(Author);Ls.name = 'Ls';Ls.book = 'My Book';Ls.sayName();Ls.sayBook();//clone 通过把F的prototype属性设置为作为参数obj传去的原型对象//函数返回的结果是一个以给定对象为原型对象的空对象function clone(obj)&#123; function F()&#123;&#125; F.prototype = obj; return new F();&#125; Es6 extendsEs6中引入了Class 和extends关键字12345678910111213141516171819202122class Person&#123; constructor(name)&#123; this.name = name; &#125; sayName()&#123; console.log(this.name) &#125; &#125;class Author extends Person&#123; constructor(name,book)&#123; super(name); this.book = book; &#125; sayBook()&#123; console.log(this.book); &#125;&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook();Ls.__proto__ === Author.prototype; //trueAuthor.prototype.__proto__ === Person.prototype; //true","tags":[{"name":"js","slug":"js","permalink":"//vivi.fenghou.site/tags/js/"}]},{"title":"彻底理解Js中的作用域和上下文","date":"2016-12-30T11:11:06.000Z","path":"2016/12/30/2016-12-30-彻底理解Js中的作用域和上下文/","text":"笔记 - 总结 - 心得函数的每次调用都有与之紧密相关的作用域和上下文这俩者是完全不同的作用域(Scope) 是基于函数的作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的而上下文(Context)是基于对象的上下文始终是this关键字的值，它是拥有(控制)当前所执行代码的对象的引用。 作用域(Scope)首先只有函数具有作用域也就是说，在一个函数内部声明的变量在函数外部无法访问JavaScript的作用域是词法性质的这这意味着函数运行在定义它的作用域中而不是在调用它的作用域中12345678910function foo()&#123; var a = 10; function bar()&#123; a *= 2; return a; &#125; return bar;&#125;var baz = foo();baz(); //20 Es6之前 局部变量只能存在于函数体中Es6开始支持let声明变量 局部变量能存在于块级作用域通过var声明的变量会出现变量提升的问题 变量的 声明周期 声明阶段(Declaration phase) 初始化阶段(Initialization phase) 初始化阶段：variable = undefined 赋值阶段(Assignment phase) 赋值阶段后：variable = ‘value’ var变量在函数作用域的开始位置就完成了声明阶段(variable)和初始化阶段(var variable)，这两个阶段之间没有任何间隙let变量通过声明阶段(foo)后，会进去暂时性死区，此时变量不可访问，直到初始化阶段(let foo)之后，变量才可以被访问所以变量提升是变量的耦合声明并且在作用域的顶部完成初始化然而let生命周期中将声明和初始化阶段解耦。这一解耦使 let 的变量提升现象消失。 上下文(Context)上下文通常取决于函数是如何被调用的1234567891011121314151617181920212223242526//当一个函数作为对象中的一个方法被调用的时候,this就设置为调用该方法的对象var foo = &#123; bar:function()&#123; console.log(this === foo) &#125;&#125;foo.bar() // true//当使用new操作符创造对象的实例时,函数的作用域内部this的值被设置为新创建的实例let aThis = [];function foo(x)&#123; this.x = x; aThis.push(this); console.log(this); //foo&#123;x:1&#125; //foo&#123;x:2&#125;&#125;foo.prototype.baz = function()&#123; console.log(this.x); //1 //2&#125;new foo(1);new foo(2);aThis.forEach(function(item)&#123; item.baz();&#125;) 执行环境(execution context)执行环境 定义了变量或函数有权访问的数据，决定它们各自的行为Js是单线程的，当JavaScript解释器初始化执行代码时，会默认进入全局执行环境此后函数的每次调用都会创建一个新的执行环境每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境会被推入一个环境栈中在函数执行完后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个便利的机制控制着执行环境可以分为创建和执行两个阶段。在创建阶段，解析器首先会创建一个变量对象（variable object，也称为活动对象 activation object），它由定义在执行环境中的变量、函数声明、和参数组成。在这个阶段，作用域链会被初始化， this 的值也会被最终确定。在执行阶段，代码被解释执行。 作用域链(scope chain)当代码在一个环境中执行时会创建变量对象的一个作用域链作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问作用域链包含了在环境栈中的每个执行环境对应的变量对象内部环境可以通过作用域链访问所有的外部环境但是外部环境不能访问内部环境中的任何变量和函数这些环境之间的联系是线性的、有次序的 闭包闭包是指有权访问另一函数作用域中的变量的函数在函数内定义一个嵌套的函数时，就构成了一个闭包它允许嵌套函数访问外层函数的变量通过返回嵌套函数，允许你维护对外部函数中局部变量、参数、和内函数声明的访问。1234567891011121314151617181920212223242526272829303132333435363738//模块模式最流行的闭包类型之一，它允许你模拟公共的、私有的、和特权成员let Module = (function()&#123; var privateProperty = 'foo'; fucntion privateMethod()&#123; &#125; return &#123; publicProperty:'', publicMethod:function()&#123; &#125;, privilegedMethod: function()&#123; return privateMethod(arguments); &#125; &#125;&#125;)()//另一种类型的闭包被称为 立即执行的函数表达式(IIFE) Es5中(function(window)&#123; var foo, bar; function private()&#123; // do something &#125; var Module = &#123; public: function()&#123; // do something &#125; &#125;; window.Module = Module;&#125;)(this);//保护全局命名空间免受变量污染var baz;(function()&#123; var foo = 10; var bar = 2; baz = function()&#123; return foo * bar; &#125;&#125;)()baz(); //20//保护私用private变量 apply&amp;call&amp;bindapply和call内建在所有的函数中(它们是Function对象的原型方法)允许你在自定义上下文中执行函数不同点在于，call函数需要参数列表，而apply 函数需要你提供一个参数数组 1234567891011121314151617181920//argumentsfunction foo()&#123; [].slice.apply(arguments); [].sort.apply(arguments,function(a,b)&#123; return a&gt;b; &#125;)&#125;//apply在传递参数时会将数组转变成列表集合//在一些只能处理列表的方法中可以巧妙地处理//求数组最大值let a = [1,2,3];Math.max(1,2,3); //3Math.max.apply(this,a); //3//两个数组合并let a = [1,2], b = [3,4];//a.push(b)//a [1,2,[3,4]];[].push.apply(a,b)//a [1,2,3,4]; 在ES5中引入了 Function.prototype.bind 方法，用于控制函数的执行上下文，它会返回一个新的函数，并且这个新函数会被永久的绑定到 bind 方法的第一个参数所指定的对象上，无论该函数被如何使用。 1234567891011//低版本浏览器，我们可以简单的对它进行实现如下(polyfill)if(!('bind' in Function.prototype))&#123; Function.prototype.bind = function()&#123; var fn = this, context = arguments[0], args = Array.prototype.slice.call(arguments, 1); return function()&#123; return fn.apply(context, args.concat(arguments)); &#125; &#125;&#125; Es6箭头函数S6中的箭头函数可以作为 Function.prototype.bind() 的替代品。和普通函数不同，箭头函数没有它自己的this值，它的 this 值继承自外围作用域。12345678910111213141516171819202122232425var Obj = &#123; baz:.. foo:function()&#123; let self = this; [1,2,4,5].forEach(function(item)&#123; self.baz(item); &#125;) &#125;&#125;//Es5 bindvar Obj = &#123; baz:.. foo:function()&#123; [1,2,4,5].forEach(function(item)&#123; self.baz(item); &#125;.bind(this)) &#125;&#125;//Es6箭头函数var Obj = &#123; baz:.. foo:function()&#123; [1,2,4,5].forEach((item)=&gt;this.baz(item)) &#125;&#125;","tags":[{"name":"js","slug":"js","permalink":"//vivi.fenghou.site/tags/js/"}]},{"title":"ECMA-prototype","date":"2016-12-28T11:09:23.000Z","path":"2016/12/28/2016-12-28-ECMA-prototype/","text":"要学好Js，首先必须得先理解原型(prototype)why？js作为面向对象的语言，实现面向对象的机制就是原型！都说js中一切皆对象,那到底什么是对象呢？ 对象是属性的集合，并有一个原型对象。原型对象可以是空值。 按宿主环境分可以分为 原生对象：由ECMAScript规范定义其语义的对象 内置对象：由ECMAScript实现提供，独立于宿主环境的对象，ECMAScript程序开始执行时就存在(所有内置对象是原生对象) 宿主对象：由宿主环境提供的对象，用于完善ECMAScript执行环境(DOM,BOM) 按功能分可以分为： 普通对象：无原型对象 函数对象：有原型对象(函数对象的一个实例) 我们这里只关注函数对象那么到底什么是原型呢？ 1234567891011121314151617181920212223242526272829303132//凡是通过new Function() 创建的对象都是函数对象function Bar()&#123;&#125;var foo = function()&#123;&#125;var baz = new Function();//Bar foo baz 都是函数对象//原型对象本质是函数对象的一个实例function Bar()&#123;&#125;Bar.prototypevar temp = new Bar();Bar.prototype = temp;var temp = new Function();Function.prototype = temp//构造器：创建和初始化对象的函数对象(在原型对象prototype中,prototype.constructor)//原型对象prototype中都有个预定义的constructor属性，用来引用它的函数对象//每个由构造器创建的对象拥有一个执行构造器prototype的属性值的隐式引用//这个引用称之为原型//每个原型可以拥有指向自己原型的隐式引用(原型的原型),就是所谓的原型链//每个对象都有一个__proto__属性来实现对原型的隐式引用function Person()&#123;&#125;Person.prototype = &#123; name:'Louis', age:'24'&#125;var person = new Person();person.__proto__ = Person.prototypePerson.prototype.__proto__ = Object.prototypeObject.prototype.__proto__ = null//person对象由构造器Person创建//所以person对Person.prototype有隐式引用(__proto__)//Person对象又是由构造器Object创建//所以Person对Object.prototype有隐式引用(__proto__)","tags":[{"name":"js","slug":"js","permalink":"//vivi.fenghou.site/tags/js/"}]},{"title":"你真的学好Js了吗","date":"2016-12-27T11:08:58.000Z","path":"2016/12/27/2016-12-27-你真的学好Js/","text":"在我看来前端(Js)就好比是个剑客江湖江湖中有人练react宝典，有人练vue神功有人锻造webpack利剑…而Js就是这些的基础心法，决定这些宝典,神功最后在你手上的杀伤力那么作为最基础的心法，你真的参透的了吗？ 这里简单的记录些Js的一些特点 面向对象什么是面向对象 一切事物皆对象对象具有封装和继承特性对象与对象之间使用消息通信，各自存在信息隐藏 众所周知Java采用面向对象思想构造其语言，它实现了类、继承、多态、接口等机制。但是这些机制，只是实现面向对象编程的一种方式实际上，Js是通过原型的方式来实现面向对象编程的Js中的对象是依靠构造器(constructor)利用原型(prototype)构造出来的 1234567891011121314151617//对象的声明//字面式对象声明var person = &#123; name:'Louis', age:'24'&#125;//使用函数构造器构造对象function Person()&#123;&#125;Person.prototype = &#123; name:'Louis', age:'24'&#125;var person = new Person();//这里的new关键字跟java中 的new毫无关系//只是借用了它的关键字new//用来表示调用构造器创建对象 弱类型语言在Js中，定义变量不必声明其类型。但这不意味着变量没有类型。原始类型：布尔型、数值型、字符串类型引用类型：对象类型(数组是一种特殊的对象)、函数类型其他类型：空类型和未定义类型js中的变量可以根据所附的值改变类型原始类型按值传送，在栈内存中存的是变量的值引用类型则按引用传送，在栈内存中存的是 引用对象在堆内存中的地址所以这里涉及到引用类型深拷贝和浅拷贝的问题 1234567891011121314151617181920//浅拷贝 把父对象的属性全部拷贝给子对象//如果父元素的属性对应的值是引用类型，那子对象对应的属性的值还是引用类型的内存地址//这个时候就需要深拷贝function deepCopy(pre)&#123; var ch = pre.constructor === Array ? [] : &#123;&#125;; if(typeof pre !== 'object')&#123; ch = pre; &#125; else if(window.JSON)&#123; ch = JSON.parse(JSON.stringify(pre)) &#125; else&#123; for(var i in pre)&#123; ch[i] = typeof pre[i] === 'object' ? (pre[i].constructor === Array ? pre[i].slice() : deepCopy(pre[i])) : pre[i] &#125; &#125; return ch;&#125; 函数是一等对象在JavaScript中，函数是一等对象可以存储在变量中可以作为参数传给其他函数可以作为返回值从其他函数传出还可以在运行时进行构造可以用function(){…}这样的语法创建匿名函数 12345(function()&#123; var foo = 20; var bar = 2; alert(foo*bar);&#125;)() 这个函数在定义后便会立即执行匿名函数可以用来创建闭包闭包是一个受到保护的变量空间由内嵌函数生成 对象的易变性JavaScript中,一切都是对象除了三种原始类型(布尔型、数值型、字符串类型)即便是这几种类型在必要时候也会被自动封装成对象而且所有对象都是易变的(mutable) 123456789101112131415161718192021222324252627//为函数添加属性function dispalyError(message)&#123; dispalyError.numTimesExecuted++; alert(message);&#125;dispalyError.numTimesExecuted = 0;//对定义的类和实例化的对象进行修改function Person(name,age)&#123; this.name = name; this.age = age;&#125;Person.prototype = &#123; getName:function()&#123; return this.name; &#125;, getAge:function()&#123; return this.age; &#125;&#125;var alice = new Person('Alice',39);var bill = new Person('Bill',20);Person.prototype.getGreeting = function()&#123; return 'Hi '+ this.getName()+'!';&#125;alice.displayGreeting = function()&#123; alert(this.getGreeting);&#125; 继承继承在JavaScript中不像在别的面向对象语言中那样简单JavaScript使用的是基于对象的继承它也可以用来模仿基于类的继承Es6中新增了extends实现继承后面会有文章相信讲讲继承","tags":[{"name":"js","slug":"js","permalink":"//vivi.fenghou.site/tags/js/"}]},{"title":"1px != 1px -- 移动端适配浅析","date":"2016-12-19T11:06:45.000Z","path":"2016/12/19/2016-12-19-移动端适配/","text":"css中我们一般使用px作为单位在pc上css中的1个像素往往对应着电脑屏幕中的1个物理像素这可能会给我们造成一个错觉css中的像素等于设备的物理像素但实际情况却并非如此css中的像素只是一个抽象的单位在不同的设备或不同的环境中css中的1px所代表的设备物理像素是不同的 典型的就是retina屏 首先我们先了解几个概念 viewportviewport 是用户网页的可视区域pc中就是屏幕宽度移动设备中viewport(这个虚拟窗口)比屏幕宽 一般为980 1234567891011&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;移动端布局viewport的宽度设为理想宽度layout viewport 默认的viewport 比屏幕宽 document.documentElement.clientWidthvisual viewport 浏览器可视区域的大小 window.innerWidthideal viewport 最适合移动设备的viewportwidth：控制 viewport 的大小，可以指定的一个值，如果 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。height：和 width 相对应，指定高度。initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。maximum-scale：允许用户缩放到的最大比例。minimum-scale：允许用户缩放到的最小比例。user-scalable：用户是否可以手动缩放。 物理像素(physical pixel)一个物理像素是显示器(手机屏幕)上最小的物理显示单元在操作系统的调度下每一个设备像素都有自己的颜色值和亮度值。 设备独立像素(density-independent pixel)设备独立像素(也叫密度无关像素)可以认为是计算机坐标系统中得一个点这个点代表一个可以由程序使用的虚拟像素(比如: css像素)简单点就是屏幕宽高 设备像素比(device pixel ratio)设备像素比 ＝ 物理像素 / 设备独立像素5,6的dpr=2，1个css像素等于2个物理像素6p的dpr=3,1个css像素等于3个物理像素 那首先我们在移动端布局，viewport肯定不能是默认的值最终viewport宽度等于应该等于设备的宽度我们的布局视图应该是 按照物理像素来布局设备独立像素可获得设备像素比 window.devicePixelRatio现在假设 在iphone6上布局 此时dpr = 2,dip = 375物理像素应该是 dpr * dip = 750div{border-top:1px solid #000;}现在在页面上要实现一个1px的上边框由于移动端布局viewport缩成设备宽度而分辨率没有变所以这时的1px会有2px的效果 这个时候可以手动将viewport 宽度设成物理像素的宽度，然后将整个页面缩小 dpr 倍 1px 的问题解决了，那如何解决在不同手机显示设计稿中的一个100x100的div设计稿 750其中div 100x100750的设计稿对应的是iPhone6结合上面viewport的缩放div{width:100px;height:100px;}在6上跟设计稿是完全相同的而在5(640)上会变大 这个时候可以通过rem在不同设备上动态计算出比例值 假设在750设计稿中 1rem = 100px那么在640设计稿中 1rem = 640/750*100px此时1rem 不管在5上还是6上显示都完全跟在设计稿中显示效果相同 123456789101112//html&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;//动态计算remvar domDocEL = window.document.documentElement, mateViewPort = window.document.querySelector('meta[name=\"viewport\"]'), nBasePsdWidth = 750 / 100, nDpr = window.devicePixelRatio, nScale = 1 / nDpr, nLayout = domDocEL.clientWidth, nRem = nLayout * nDpr / nBasePsdWidth;domDocEL.style.fontSize = rem +'px';mateViewPort.setAttribute('content','width='+nDpr*nLayout+',initial-scale='+nScale+',maximum-scale='+nScale+',minimum-scale='+nScale+',user-scalable=no'); 对于字体可以用写个mixin方法根据不同的dpr设置字号 12345@mixin px2rem($name,$px) &#123; [data-dpr=\"2\"] &amp; &#123; #&#123;$name&#125;: $px*2/2+px; &#125; &#125; 总结移动端布局将viewport设成物理像素的大小,然后在缩放为dpr的倒数倍。dpr不存在？简单点~~~那就指定为1！","tags":[{"name":"css","slug":"css","permalink":"//vivi.fenghou.site/tags/css/"},{"name":"rem","slug":"rem","permalink":"//vivi.fenghou.site/tags/rem/"}]},{"title":"MarkDown语法","date":"2016-12-12T02:25:27.000Z","path":"2016/12/12/2016-12-12-md-rule/","text":"markdown 部分语法 AB 亮不亮 我的博客 ES JS JS1 数据结构 树 二叉树 平衡二叉树 满二叉树 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 加删除线像这样用： 删除这些 [x] 支持 @提到某人、#引用、链接、格式化 和 标签 等语法 [x] 需要使用列表语法来激活（无序或有序列表均可） [x] 这是一个已完成项目 [ ] 这是一个未完成项目","tags":[{"name":"markdown","slug":"markdown","permalink":"//vivi.fenghou.site/tags/markdown/"}]}]