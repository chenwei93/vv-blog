<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vivi Blog</title>
  <icon>https://www.gravatar.com/avatar/592f14cc1891bc06300db1e5fd2a93ef</icon>
  <subtitle>Vivi</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//vivi.fenghou.site/"/>
  <updated>2018-01-16T03:02:03.000Z</updated>
  <id>//vivi.fenghou.site/</id>
  
  <author>
    <name>Vivi</name>
    <email>1172998431@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018-1-16-演习</title>
    <link href="//vivi.fenghou.site/2018/01/16/2018-1-16-%E6%BC%94%E4%B9%A0/"/>
    <id>//vivi.fenghou.site/2018/01/16/2018-1-16-演习/</id>
    <published>2018-01-16T03:01:25.000Z</published>
    <updated>2018-01-16T03:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>请注意，这只是个演习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请注意，这只是个演习。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-about</title>
    <link href="//vivi.fenghou.site/2017/11/17/2017-11-17-vue-about/"/>
    <id>//vivi.fenghou.site/2017/11/17/2017-11-17-vue-about/</id>
    <published>2017-11-17T06:30:23.000Z</published>
    <updated>2018-01-16T02:33:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>VUE-ABOUT</p><a id="more"></a><h3 id="vue中-scope的实现"><a href="#vue中-scope的实现" class="headerlink" title=".vue中 scope的实现"></a>.vue中 scope的实现</h3><p>vue文件可以实现当前文件的css作用域<br>实现手法是通过vue-loader后生成一个<br>随机字符串属性 通过内置css属性选择器实现<br>like that<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"scope-div"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scope</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .scope-div&#123;</span></span><br><span class="line"><span class="undefined">        width: 200px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--打包处理后--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .scope-div[data-v-7af99ee4]&#123;</span></span><br><span class="line"><span class="undefined">        width: 200px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"scope-div"</span> <span class="attr">data-v-7af99ee4</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>Vuex 中模块的划分<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"><span class="keyword">import</span> ware <span class="keyword">from</span> <span class="string">'./module/wareModule'</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    viewImageConfig:&#123;</span><br><span class="line">      isShow:<span class="literal">false</span>,</span><br><span class="line">      url:<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations,  <span class="comment">// 修改store方法</span></span><br><span class="line">  actions,    <span class="comment">// 调用修改store方法</span></span><br><span class="line">  modules: &#123;</span><br><span class="line">    ware</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//actions.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    demoAction(&#123;commit&#125;)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ware.js</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  demoWareStore:<span class="string">'345'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  getDemoWareStore: <span class="function"><span class="params">state</span> =&gt;</span> state.demoWareStore</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  demoWareAction(&#123;commit,state&#125;,rs)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rs)</span><br><span class="line">    commit(<span class="string">'DEMO_WARE_MUT'</span>,rs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  DEMO_WARE_MUT(state,rs)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rs)</span><br><span class="line">    state.demoWareStore = <span class="string">'123'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  actions,</span><br><span class="line">  mutations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>vuex 实例会混入vue的实例中<br>通过this.$store<br>而模块中引入的 action mutations getters 都会和全局混合在一起<br>this.$store._actions[demoWareAction,demoAction]<br>而state会根据module分割<br>this.$store.store.viewImageConfig<br>this.$store.store.ware.demoWareStore</p><h3 id="Vue中路由-层级的渲染"><a href="#Vue中路由-层级的渲染" class="headerlink" title="Vue中路由 层级的渲染"></a>Vue中路由 层级的渲染</h3><p>首先Router和route 会混入到vue的实例中去<br>vue-router 提供了 一个 router-view 的组件<br>如果是嵌套的路由 vue-router 是怎么实现对应的显示<br>首先在 在显示 当前组件时 vue-router 会根据当前路由<br>生成一个 已经匹配过的数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$route = &#123;</span><br><span class="line">    path:<span class="string">'/part'</span>,</span><br><span class="line">    matched:[</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">''</span>,</span><br><span class="line">            name:<span class="string">'Home'</span>,</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/part'</span>,</span><br><span class="line">            name:<span class="string">'Part'</span>,</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>渲染 vue-router 时 会去判断 当前组件的层级<br>然后对应去 这个 matched 中取层级下标对应的值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> route = parent.$route</span><br><span class="line"><span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> inactive = <span class="literal">false</span></span><br><span class="line"><span class="keyword">while</span> (parent &amp;&amp; parent._routerRoot !== parent) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parent.$vnode &amp;&amp; parent.$vnode.data.routerView) &#123;</span><br><span class="line">        depth++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (parent._inactive) &#123;</span><br><span class="line">        inactive = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      parent = parent.$parent </span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">const</span> matched = route.matched[depth]</span><br><span class="line"> <span class="comment">//此时mathed 就是匹配到要渲染的 组件</span></span><br></pre></td></tr></table></figure></p><p>举例说明<br>路由配置如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    routes:[</span><br><span class="line">       &#123;</span><br><span class="line">            path: <span class="string">'/'</span>,</span><br><span class="line">            name: <span class="string">'Home'</span>,</span><br><span class="line">            component: Home,</span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">'/part'</span>,</span><br><span class="line">                    name: <span class="string">'Part'</span>,</span><br><span class="line">                    component: Part,</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">           </span><br><span class="line">       &#125; </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--App--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Home--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"readyMenu"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">v-head</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">v-menu</span>&gt;</span><span class="tag">&lt;/<span class="name">v-menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-box"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"move"</span> <span class="attr">mode</span>=<span class="string">"out-in"</span>&gt;</span><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">v-load</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">v-toast</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Part--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    Part</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由为 localhost:8010/#/时 </span></span><br><span class="line">$route = &#123;</span><br><span class="line">    path:<span class="string">'/'</span>,</span><br><span class="line">    matched:[</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">''</span>,</span><br><span class="line">            name:<span class="string">'Home'</span>,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时</span></span><br><span class="line">depth = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> matched = route.matched[depth]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由为 localhost:8010/#/part时 </span></span><br><span class="line">$route = &#123;</span><br><span class="line">    path:<span class="string">'/part'</span>,</span><br><span class="line">    matched:[</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">''</span>,</span><br><span class="line">            name:<span class="string">'Home'</span>,</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">''</span>,</span><br><span class="line">            name:<span class="string">'Part'</span>,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先渲染Home之后</span></span><br><span class="line">depth = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> matched = route.matched[depth]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VUE-ABOUT&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="//vivi.fenghou.site/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>css-Box-Model</title>
    <link href="//vivi.fenghou.site/2017/11/07/2017-11-07-css-box-model/"/>
    <id>//vivi.fenghou.site/2017/11/07/2017-11-07-css-box-model/</id>
    <published>2017-11-07T01:56:43.000Z</published>
    <updated>2018-01-16T02:33:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>css-box 总结<br><a id="more"></a></p><h3 id="盒模型的计算"><a href="#盒模型的计算" class="headerlink" title="盒模型的计算"></a>盒模型的计算</h3><p>盒模型 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式 </p><p>盒模型 宽高的计算<br>box-sizing 属性可以通俗的理解为 给box设置的宽高从哪里开始计算<br>盒模型的真实宽高 = border-box + padding-box + content-box</p><p>box-sizing: content-box(标准盒模型)  表示设置的宽高是 content-box的宽高 那渲染在页面上真实的宽高还要加上 padding-box 和 border-box<br>width(真实) = width(content-box设置的width) + padding-box + border-box</p><p>box-sizing: border-box(IE盒模型)   表示设置的宽高是 border-box的宽高 那渲染在页面上真实的宽高就是 设置的宽高<br>width(真实) = width(设置的width) </p><p>box-sizing: inherit 从父元素继承 </p><h3 id="BFC-amp-amp-IFC"><a href="#BFC-amp-amp-IFC" class="headerlink" title="BFC &amp;&amp; IFC"></a>BFC &amp;&amp; IFC</h3><p>BFC 块级格式化上下文<br>可以通过构建BFC 解决margin 重合 清除浮动<br>float的值不为none<br>position的值不为static或者relative<br>display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个<br>overflow的值不为visible</p><p>IFC 内联格式化上下文<br>默认对齐方式 vertical-align:baseline 所以同时存在有内容的内联元素和没内容的内联元素 有内容的 会往下掉<br>vertical-align:top</p><h3 id="背景的起始"><a href="#背景的起始" class="headerlink" title="背景的起始"></a>背景的起始</h3><p>background-clip 表示背景在盒模型中显示的位置<br>border-box  从border-box开始有背景<br>padding-box 从padding-box开始有背景<br>content-box 从content-box开始有背景<br>background-origin 表示背景在盒模型中开始渲染的位置<br>border-box 背景从border-box 处开始渲染<br>padding-box 背景从padding-box 处开始渲染<br>content-box 背景从content-box 处开始渲染</p><p>background-position 表示从这张背景图片的什么位置 开始渲染在 元素背景上<br>background-position:X% Y%(百分比值) 表示会把图片 横向X% 纵向的Y% 的点与 元素 横向X% 纵向的Y%点对齐<br>background-position:Xpx Ypx(数值)  表示图片距离背景起始绘制点的距离   </p><p>background-position: <background-origin> <background-clip> <background-position>/<background-size></background-size></background-position></background-clip></background-origin></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css-box 总结&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="//vivi.fenghou.site/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>浏览器中js事件运行机制</title>
    <link href="//vivi.fenghou.site/2017/08/08/2017-08-08-js-event-loop/"/>
    <id>//vivi.fenghou.site/2017/08/08/2017-08-08-js-event-loop/</id>
    <published>2017-08-08T08:28:27.000Z</published>
    <updated>2018-01-16T02:33:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下 浏览器中js事件运行机制<br><a id="more"></a><br>起因是女票今天问我一个问题<br>问题如下</p><h3 id="alert引起的争论"><a href="#alert引起的争论" class="headerlink" title="alert引起的争论"></a>alert引起的争论</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>,</span><br><span class="line">    domProcess = <span class="built_in">document</span>.querySelector(<span class="string">'#process'</span>),</span><br><span class="line">    inter = <span class="literal">null</span></span><br><span class="line">inter = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">100</span>)&#123;</span><br><span class="line">        domProcess.innerText = count+<span class="string">'%'</span></span><br><span class="line">        <span class="built_in">console</span>.log(count)</span><br><span class="line">        alert(<span class="string">'加载完成'</span>)</span><br><span class="line">        clearInterval(inter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">100</span>)</span><br><span class="line"><span class="comment">//弹框时 为什么页面上process显示的是99%？</span></span><br></pre></td></tr></table></figure><p>因为前段时间了解过Event-Loop的机制 知道怎么去解决它<br>但是要跟女票讲清楚 还是得在总结总结 毕竟自己也是了解的不深</p><h3 id="单线程-amp-amp-任务队列-amp-amp-Event-Loop"><a href="#单线程-amp-amp-任务队列-amp-amp-Event-Loop" class="headerlink" title="单线程 &amp;&amp; 任务队列 &amp;&amp; Event-Loop"></a>单线程 &amp;&amp; 任务队列 &amp;&amp; Event-Loop</h3><blockquote><p><img src="/assets/blogImg/2017-08-08-js-event-loop.png" alt="eventLoop"><br>图片来自Philip Roberts的演讲《Help, I’m stuck in an event-loop》<br><a href="http://v.youku.com/v_show/id_XMjY5MTkwMDYzNg==.html" target="_blank" rel="noopener">Help, I’m stuck in an event-loop优酷地址</a></p></blockquote><p>首先Js是单线程的 异步是浏览器的事(宿主环境)<br>主线程运行的时候 产生堆(heap)和栈(stack)<br>主线程将运行中碰到的事件推入 执行栈中 开始执行<br>执行结束后 弹出执行栈 推入下一个事件<br>当执行到webAPI时 会将它当做任务源(相当于是分发任务)来执行 并且弹出<br>这时候会产生一个待执行的任务<br>当这个任务满足执行条件时 会进入到任务队列当中<br>当执行栈 为空时 主线程会不断的去调取任务队列中任务 推入 执行栈中执行 这个运行机制就是 Event-Loop<br>而任务队列 可以分为 宏任务队列(macro-task) 和 微任务队列(micro-task)<br>当执行栈为空时 主线程会先去micro-task中调取任务 micro-task为空时才会去 macro-task调取任务执行</p><blockquote><p>触发任务的webAPI<br>DOM(DOCUMENT),AJAX,setTimeOut,setInterval,Promise,process.nextTick,setImmediate<br>其中 加入宏队列中任务 DOM(DOCUMENT),AJAX,setTimeOut,setInterval,setImmediate<br>加入微任务队列中的任务 Promise,process.nextTick</p></blockquote><h3 id="真相"><a href="#真相" class="headerlink" title="真相"></a>真相</h3><p>所以 上面的js在执行中<br>遇到 <code>document.querySelector(&#39;#process&#39;).innerText = count+&#39;%&#39;</code><br>推入执行栈 由于是DOM操作判定为任务源 推出执行栈<br>满足执行条件 加入到 宏任务队列<br>遇到 <code>console.log(count)</code><br>推入执行栈 控制台输出 100 推出执行栈<br>遇到 <code>alert(&#39;加载完成&#39;)</code><br>推入执行栈 开始执行 主线程挂起 等待弹框确认<br>弹窗确认后 推出执行栈<br>遇到 <code>clearInterval(inter)</code><br>推入执行栈 执行 推出执行栈<br>此时执行栈为空 开始调用 任务队列<br>微任务队列为空 直接调用宏任务队列<br>将 <code>document.querySelector(&#39;#process&#39;).innerText = count+&#39;%&#39;</code> dom操作分发的执行任务推入执行栈<br>渲染页面数据 推出执行栈</p><p>所以要解决这个问题 只需要加个setTimeout就能解决问题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="string">'加载完成'</span>) </span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>这里有个问题就是 碰到这个webAPI时 并不是把 这些webAPI推入任务队列<br>在执行栈中 这些webAPI还是立即执行的 是把它分发的任务 推入任务队列<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//譬如</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'log'</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="comment">//setTimeOut 会立即进入执行栈 并且执行</span></span><br><span class="line"><span class="comment">//它的第一个参数就是他要分发的任务 会在满足它的分发条件后进入任务队列 </span></span><br><span class="line"><span class="comment">// 上例就是1000ms后进入任务队列</span></span><br></pre></td></tr></table></figure></p><p>再看下面的两个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo 1</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">8</span>);&#125;,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">reslove</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">     reslove()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//demo 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="number">2.2</span>+x)</span><br><span class="line">   &#125;,<span class="number">0</span>)</span><br><span class="line">   <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="number">2.1</span>+x);</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="number">1</span>+x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    A(<span class="string">'B'</span>)</span><br><span class="line">&#125;</span><br><span class="line">A(<span class="string">'A'</span>)</span><br><span class="line">B()</span><br></pre></td></tr></table></figure></p><p>联系上面的分析<br>第一题的输出 应该是 1 2 3 4 5 6 7 8</p><p>第二题的输出 应该是 1A 1B 2.1A 2.1B 2.2A 2.2B</p><p>写在一块输出 应该是 1 2 1A 1B 3 4 2.1A 2.1B 5 6 7 2.2A 2.2B 8</p><blockquote><p>参考文章<br><a href="http://www.cnblogs.com/woodyblog/p/6061671.html" target="_blank" rel="noopener">js的单线程和异步</a><br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a><br><a href="http://www.jianshu.com/p/12b9f73c5a4f" target="_blank" rel="noopener">前端基础进阶（十二）：深入核心，详解事件循环机制</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下 浏览器中js事件运行机制&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="//vivi.fenghou.site/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Vue事件</title>
    <link href="//vivi.fenghou.site/2017/07/20/2017-07-20-vue-event/"/>
    <id>//vivi.fenghou.site/2017/07/20/2017-07-20-vue-event/</id>
    <published>2017-07-20T02:18:56.000Z</published>
    <updated>2018-01-16T02:33:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>vue 中通过[$on]注册事件[$emit]来触发事件<br>这里来模拟一下它内部的实现机制<br>超简易<br><a id="more"></a></p><h3 id="初始化Vue"><a href="#初始化Vue" class="headerlink" title="初始化Vue"></a>初始化Vue</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">V</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._init()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMixin</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    v.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        initEvent(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">initMixin(V)</span><br></pre></td></tr></table></figure><h3 id="初始化事件"><a href="#初始化事件" class="headerlink" title="初始化事件"></a>初始化事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initEvent</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    v._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="混合事件"><a href="#混合事件" class="headerlink" title="混合事件"></a>混合事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventsMixin</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    v.prototype.$on = <span class="function"><span class="keyword">function</span>(<span class="params">name,fn</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._events[name] = fn</span><br><span class="line">    &#125;</span><br><span class="line">    v.prototype.$emit = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cbs = <span class="keyword">this</span>._events[event]</span><br><span class="line">        <span class="keyword">let</span> args = toArray(<span class="built_in">arguments</span>,<span class="number">1</span>)</span><br><span class="line">        cbs.apply(<span class="keyword">this</span>,args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">eventsMixin(V)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span> (<span class="params">list, start</span>) </span>&#123;</span><br><span class="line">    start = start || <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> i = list.length - start</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">new</span> <span class="built_in">Array</span>(i)</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        ret[i] = list[i + start]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> V()</span><br><span class="line">v.$on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg)</span><br><span class="line">&#125;)</span><br><span class="line">v.$emit(<span class="string">'click'</span>,<span class="string">'emit'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue 中通过[$on]注册事件[$emit]来触发事件&lt;br&gt;这里来模拟一下它内部的实现机制&lt;br&gt;超简易&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="//vivi.fenghou.site/tags/js/"/>
    
      <category term="vue" scheme="//vivi.fenghou.site/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>谈谈js的继承</title>
    <link href="//vivi.fenghou.site/2017/01/03/2017-01-03-%E8%B0%88%E8%B0%88js%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>//vivi.fenghou.site/2017/01/03/2017-01-03-谈谈js的继承/</id>
    <published>2017-01-03T11:11:44.000Z</published>
    <updated>2018-01-16T02:33:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>继承在JavaScript中不像在别的面向对象语言中那样简单<br>JavaScript使用的是基于对象的继承<br>它可以用来模仿基于类的继承<br><a id="more"></a><br>Es6中，新增了Class和extends关键字来支持类的继承<br>在这里记录各种继承的实现方式</p><h3 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h3><p>JavaScript对象可以模仿Java中的对象<br>通过函数来声明类<br>用关键字new来创建实例<br>这种方式包括两个步骤<br>1.用一个类的声明定义对象的结构<br>2.实例化该类创建一个新对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sName);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Ls = <span class="keyword">new</span> Person(<span class="string">'Ls'</span>);</span><br><span class="line">Ls.sayName();</span><br></pre></td></tr></table></figure></p><p>这种类式继承的方式可以分为五种<br>对象冒充，Call，Apply，原型链和混合模式</p><h3 id="对象冒充"><a href="#对象冒充" class="headerlink" title="对象冒充"></a>对象冒充</h3><p>构造函数使用 this 关键字给所有属性和方法赋值<br>因为构造函数只是一个函数<br>所以可使Person构造函数成为Author的方法，然后调用它<br>Author就会收到Person的构造函数中定义的属性和方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Author</span>(<span class="params">name,book</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.book = book;</span><br><span class="line">        <span class="keyword">this</span>.Person = Person;</span><br><span class="line">        <span class="keyword">this</span>.Person(name);</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.Person;</span><br><span class="line">        <span class="keyword">this</span>.sayBook = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.book)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Ls = <span class="keyword">new</span> Author(<span class="string">'Ls'</span>,<span class="string">'My Book'</span>);</span><br><span class="line">Ls.sayName();</span><br><span class="line">Ls.sayBook();</span><br></pre></td></tr></table></figure></p><h3 id="apply-amp-amp-call继承"><a href="#apply-amp-amp-call继承" class="headerlink" title="apply&amp;&amp;call继承"></a>apply&amp;&amp;call继承</h3><p>call和apply方法通过改变函数上下文实现继承<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Author</span>(<span class="params">name,book</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.book = book;</span><br><span class="line">        Person.call(<span class="keyword">this</span>,name);</span><br><span class="line">        Person.apply(<span class="keyword">this</span>,[name]);</span><br><span class="line">        <span class="keyword">this</span>.sayBook = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.book)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Ls = <span class="keyword">new</span> Author(<span class="string">'Ls'</span>,<span class="string">'My Book'</span>);</span><br><span class="line">    Ls.sayName();</span><br><span class="line">    Ls.sayBook();</span><br></pre></td></tr></table></figure></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>使子类原型对象指向父类的实例以实现继承,即重写类的原型对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sName = <span class="string">''</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sName);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Author</span>(<span class="params">book</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.book = book;</span><br><span class="line">&#125;</span><br><span class="line">Author.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">Author.prototype.sayBook= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.book);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Ls = <span class="keyword">new</span> Author(<span class="string">'My book'</span>);</span><br><span class="line">Ls.sName = <span class="string">'Ls'</span>;</span><br><span class="line">Ls.sayName();</span><br><span class="line">Ls.sayBook();</span><br></pre></td></tr></table></figure></p><p>这种模式无法使用带参数的构造函数，不支持多重继承</p><h3 id="混合模式继承"><a href="#混合模式继承" class="headerlink" title="混合模式继承"></a>混合模式继承</h3><p>用对象冒充继承构造函数的属性，用原型链继承 prototype 对象的方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Author</span>(<span class="params">name,book</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>,name);</span><br><span class="line">    <span class="keyword">this</span>.book = book;</span><br><span class="line">&#125;</span><br><span class="line">Author.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">Author.prototype.constructor = Author;</span><br><span class="line">Author.prototype.sayBook = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.book);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Ls = <span class="keyword">new</span> Author(<span class="string">'Ls'</span>,<span class="string">'My Book'</span>);</span><br><span class="line">Ls.sayName();</span><br><span class="line">Ls.sayBook();</span><br></pre></td></tr></table></figure></p><p>为了简化类的声明，可以把派生子类的整个过程包装在一个名为extend的函数中<br>空函数F，这样可以避免创建Person的新实例,因为它可能会比较庞大<br>增加superclass这个属性弱化Author与Person之间的耦合<br>并且确保constructor属性被正确设置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass.superClass</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = superClass.prototype;</span><br><span class="line">    subClass.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    subClass.prototype.constructor = subClass;</span><br><span class="line">    subClass.superclass = superClass.prototype;</span><br><span class="line">    <span class="keyword">if</span>(subClass.prototype.constructor == <span class="built_in">Object</span>.prototype.constructor)&#123;</span><br><span class="line">        subClass.prototype.constructor = subClass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Author</span>(<span class="params">name,book</span>)</span>&#123;</span><br><span class="line">    Author.superclass.constructor.call(<span class="keyword">this</span>,name);</span><br><span class="line">    <span class="keyword">this</span>.book = book;</span><br><span class="line">&#125;</span><br><span class="line">extend(Author,Person)</span><br><span class="line">Author.prototype.sayBook = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.book);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Ls = <span class="keyword">new</span> Author(<span class="string">'Ls'</span>,<span class="string">'My Book'</span>);</span><br><span class="line">Ls.sayName();</span><br><span class="line">Ls.sayBook();</span><br></pre></td></tr></table></figure></p><p>JavaScript中的类式继承仅仅是对正正基于类的继承的一种模仿</p><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>原型式继承与类式继承截然不同<br>它并不需要用类来定义对象结构，只需要创建一个对象<br>这个对象可以被新的对象重用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    name:<span class="string">'default name'</span>,</span><br><span class="line">    sayName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Author = clone(Person);</span><br><span class="line">Author.book = <span class="string">'default book'</span>;</span><br><span class="line">Author.sayBook = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.book);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Ls = clone(Author);</span><br><span class="line">Ls.name = <span class="string">'Ls'</span>;</span><br><span class="line">Ls.book = <span class="string">'My Book'</span>;</span><br><span class="line">Ls.sayName();</span><br><span class="line">Ls.sayBook();</span><br><span class="line"><span class="comment">//clone 通过把F的prototype属性设置为作为参数obj传去的原型对象</span></span><br><span class="line"><span class="comment">//函数返回的结果是一个以给定对象为原型对象的空对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Es6-extends"><a href="#Es6-extends" class="headerlink" title="Es6 extends"></a>Es6 extends</h3><p>Es6中引入了Class 和extends关键字<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        sayName()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(name,book)&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            <span class="keyword">this</span>.book = book;</span><br><span class="line">        &#125;</span><br><span class="line">        sayBook()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.book);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Ls = <span class="keyword">new</span> Author(<span class="string">'Ls'</span>,<span class="string">'My Book'</span>);</span><br><span class="line">Ls.sayName();</span><br><span class="line">Ls.sayBook();</span><br><span class="line">Ls.__proto__ === Author.prototype; <span class="comment">//true</span></span><br><span class="line">Author.prototype.__proto__ === Person.prototype; <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继承在JavaScript中不像在别的面向对象语言中那样简单&lt;br&gt;JavaScript使用的是基于对象的继承&lt;br&gt;它可以用来模仿基于类的继承&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="//vivi.fenghou.site/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>彻底理解Js中的作用域和上下文</title>
    <link href="//vivi.fenghou.site/2016/12/30/2016-12-30-%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>//vivi.fenghou.site/2016/12/30/2016-12-30-彻底理解Js中的作用域和上下文/</id>
    <published>2016-12-30T11:11:06.000Z</published>
    <updated>2018-01-16T02:33:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔记 - 总结 - 心得<br>函数的每次调用都有与之紧密相关的作用域和上下文<br>这俩者是完全不同的<br>作用域(Scope) 是基于函数的<br>作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的<br>而上下文(Context)是基于对象的<br>上下文始终是this关键字的值，它是拥有(控制)当前所执行代码的对象的引用。<br><a id="more"></a></p><h3 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h3><p>首先只有函数具有作用域<br>也就是说，在一个函数内部声明的变量在函数外部无法访问<br>JavaScript的作用域是词法性质的<br>这这意味着函数运行在定义它的作用域中<br>而不是在调用它的作用域中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        a *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line">baz(); <span class="comment">//20</span></span><br></pre></td></tr></table></figure></p><p>Es6之前 局部变量只能存在于函数体中<br>Es6开始支持let声明变量 局部变量能存在于块级作用域<br>通过var声明的变量会出现变量提升的问题</p><blockquote><p>变量的 声明周期<br>  声明阶段(Declaration phase)<br>  初始化阶段(Initialization phase)<br>  初始化阶段：variable = undefined<br>  赋值阶段(Assignment phase)<br>  赋值阶段后：variable = ‘value’</p></blockquote><p>var<br>变量在函数作用域的开始位置就完成了声明阶段(variable)和初始化阶段(var variable)，这两个阶段之间没有任何间隙<br>let<br>变量通过声明阶段(foo)后，会进去暂时性死区，此时变量不可访问，直到初始化阶段(let foo)之后，变量才可以被访问<br>所以变量提升是变量的耦合声明并且在作用域的顶部完成初始化<br>然而let生命周期中将声明和初始化阶段解耦。这一解耦使 let 的变量提升现象消失。</p><h3 id="上下文-Context"><a href="#上下文-Context" class="headerlink" title="上下文(Context)"></a>上下文(Context)</h3><p>上下文通常取决于函数是如何被调用的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当一个函数作为对象中的一个方法被调用的时候,this就设置为调用该方法的对象</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === foo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.bar() <span class="comment">// true</span></span><br><span class="line"><span class="comment">//当使用new操作符创造对象的实例时,函数的作用域内部this的值被设置为新创建的实例</span></span><br><span class="line"><span class="keyword">let</span> aThis = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    aThis.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//foo&#123;x:1&#125;</span></span><br><span class="line">    <span class="comment">//foo&#123;x:2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">foo.prototype.baz = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> foo(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line">aThis.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    item.baz();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="执行环境-execution-context"><a href="#执行环境-execution-context" class="headerlink" title="执行环境(execution context)"></a>执行环境(execution context)</h3><p>执行环境 定义了变量或函数有权访问的数据，决定它们各自的行为<br>Js是单线程的，当JavaScript解释器初始化执行代码时，会默认进入全局执行环境<br>此后函数的每次调用都会创建一个新的执行环境<br>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境会被推入一个环境栈中<br>在函数执行完后，栈将其环境弹出，把控制权返回给之前的执行环境。<br>ECMAScript程序中的执行流正是由这个便利的机制控制着<br>执行环境可以分为创建和执行两个阶段。<br>在创建阶段，解析器首先会创建一个变量对象（variable object，也称为活动对象 activation object），<br>它由定义在执行环境中的变量、函数声明、和参数组成。<br>在这个阶段，作用域链会被初始化， this 的值也会被最终确定。<br>在执行阶段，代码被解释执行。</p><h3 id="作用域链-scope-chain"><a href="#作用域链-scope-chain" class="headerlink" title="作用域链(scope chain)"></a>作用域链(scope chain)</h3><p>当代码在一个环境中执行时<br>会创建变量对象的一个作用域链<br>作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问<br>作用域链包含了在环境栈中的每个执行环境对应的变量对象<br>内部环境可以通过作用域链访问所有的外部环境<br>但是外部环境不能访问内部环境中的任何变量和函数<br>这些环境之间的联系是线性的、有次序的</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另一函数作用域中的变量的函数<br>在函数内定义一个嵌套的函数时，就构成了一个闭包<br>它允许嵌套函数访问外层函数的变量<br>通过返回嵌套函数，允许你维护对外部函数中局部变量、参数、和内函数声明的访问。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块模式最流行的闭包类型之一，它允许你模拟公共的、私有的、和特权成员</span></span><br><span class="line"><span class="keyword">let</span> Module = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> privateProperty = <span class="string">'foo'</span>;</span><br><span class="line">    fucntion privateMethod()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicProperty:<span class="string">''</span>,</span><br><span class="line">        publicMethod:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        privilegedMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> privateMethod(<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">//另一种类型的闭包被称为 立即执行的函数表达式(IIFE) Es5中</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo, bar;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">private</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> Module = &#123;</span><br><span class="line">        public: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">window</span>.Module = Module;</span><br><span class="line">&#125;)(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//保护全局命名空间免受变量污染</span></span><br><span class="line"><span class="keyword">var</span> baz;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line">    baz = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> foo * bar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">baz(); <span class="comment">//20</span></span><br><span class="line"><span class="comment">//保护私用private变量</span></span><br></pre></td></tr></table></figure></p><h3 id="apply-amp-call-amp-bind"><a href="#apply-amp-call-amp-bind" class="headerlink" title="apply&amp;call&amp;bind"></a>apply&amp;call&amp;bind</h3><p>apply和call内建在所有的函数中(它们是Function对象的原型方法)<br>允许你在自定义上下文中执行函数<br>不同点在于，call函数需要参数列表，而apply 函数需要你提供一个参数数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    [].slice.apply(<span class="built_in">arguments</span>);</span><br><span class="line">    [].sort.apply(<span class="built_in">arguments</span>,<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//apply在传递参数时会将数组转变成列表集合</span></span><br><span class="line"><span class="comment">//在一些只能处理列表的方法中可以巧妙地处理</span></span><br><span class="line"><span class="comment">//求数组最大值</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="keyword">this</span>,a); <span class="comment">//3</span></span><br><span class="line"><span class="comment">//两个数组合并</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">    b = [<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="comment">//a.push(b)</span></span><br><span class="line"><span class="comment">//a [1,2,[3,4]];</span></span><br><span class="line">[].push.apply(a,b)</span><br><span class="line"><span class="comment">//a [1,2,3,4];</span></span><br></pre></td></tr></table></figure><p>在ES5中引入了 Function.prototype.bind 方法，<br>用于控制函数的执行上下文，它会返回一个新的函数，<br>并且这个新函数会被永久的绑定到 bind 方法的第一个参数所指定的对象上，无论该函数被如何使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//低版本浏览器，我们可以简单的对它进行实现如下(polyfill)</span></span><br><span class="line"><span class="keyword">if</span>(!(<span class="string">'bind'</span> <span class="keyword">in</span> <span class="built_in">Function</span>.prototype))&#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="keyword">this</span>,</span><br><span class="line">            context = <span class="built_in">arguments</span>[<span class="number">0</span>],</span><br><span class="line">            args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(context, args.concat(<span class="built_in">arguments</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Es6箭头函数"><a href="#Es6箭头函数" class="headerlink" title="Es6箭头函数"></a>Es6箭头函数</h3><p>S6中的箭头函数可以作为 Function.prototype.bind() 的替代品。<br>和普通函数不同，箭头函数没有它自己的this值，它的 this 值继承自外围作用域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Obj = &#123;</span><br><span class="line">    baz:..</span><br><span class="line">    foo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">            self.baz(item);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Es5 bind</span></span><br><span class="line"><span class="keyword">var</span> Obj = &#123;</span><br><span class="line">    baz:..</span><br><span class="line">    foo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">            self.baz(item);</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Es6箭头函数</span></span><br><span class="line"><span class="keyword">var</span> Obj = &#123;</span><br><span class="line">    baz:..</span><br><span class="line">    foo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>].forEach(<span class="function">(<span class="params">item</span>)=&gt;</span><span class="keyword">this</span>.baz(item))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔记 - 总结 - 心得&lt;br&gt;函数的每次调用都有与之紧密相关的作用域和上下文&lt;br&gt;这俩者是完全不同的&lt;br&gt;作用域(Scope) 是基于函数的&lt;br&gt;作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的&lt;br&gt;而上下文(Context)是基于对象的&lt;br&gt;上下文始终是this关键字的值，它是拥有(控制)当前所执行代码的对象的引用。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="//vivi.fenghou.site/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-prototype</title>
    <link href="//vivi.fenghou.site/2016/12/28/2016-12-28-ECMA-prototype/"/>
    <id>//vivi.fenghou.site/2016/12/28/2016-12-28-ECMA-prototype/</id>
    <published>2016-12-28T11:09:23.000Z</published>
    <updated>2018-01-16T02:33:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>要学好Js，首先必须得先理解原型(prototype)<br>why？<br>js作为面向对象的语言，实现面向对象的机制就是原型！<br><a id="more"></a><br>都说js中一切皆对象,那到底什么是对象呢？</p><blockquote><p>对象是属性的集合，并有一个原型对象。原型对象可以是空值。<br>  按宿主环境分可以分为<br>  原生对象：由ECMAScript规范定义其语义的对象<br>  内置对象：由ECMAScript实现提供，独立于宿主环境的对象，ECMAScript程序开始执行时就存在(所有内置对象是原生对象)<br>  宿主对象：由宿主环境提供的对象，用于完善ECMAScript执行环境(DOM,BOM)<br>  按功能分可以分为：<br>  普通对象：无原型对象<br>  函数对象：有原型对象(函数对象的一个实例)</p></blockquote><p>我们这里只关注函数对象<br>那么到底什么是原型呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//凡是通过new Function() 创建的对象都是函数对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"><span class="comment">//Bar foo baz 都是函数对象</span></span><br><span class="line"><span class="comment">//原型对象本质是函数对象的一个实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype</span><br><span class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> Bar();</span><br><span class="line">Bar.prototype = temp;</span><br><span class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">Function</span>.prototype = temp</span><br><span class="line"><span class="comment">//构造器：创建和初始化对象的函数对象(在原型对象prototype中,prototype.constructor)</span></span><br><span class="line"><span class="comment">//原型对象prototype中都有个预定义的constructor属性，用来引用它的函数对象</span></span><br><span class="line"><span class="comment">//每个由构造器创建的对象拥有一个执行构造器prototype的属性值的隐式引用</span></span><br><span class="line"><span class="comment">//这个引用称之为原型</span></span><br><span class="line"><span class="comment">//每个原型可以拥有指向自己原型的隐式引用(原型的原型),就是所谓的原型链</span></span><br><span class="line"><span class="comment">//每个对象都有一个__proto__属性来实现对原型的隐式引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name:<span class="string">'Louis'</span>,</span><br><span class="line">    age:<span class="string">'24'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.__proto__ = Person.prototype</span><br><span class="line">Person.prototype.__proto__ = <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ = <span class="literal">null</span></span><br><span class="line"><span class="comment">//person对象由构造器Person创建</span></span><br><span class="line"><span class="comment">//所以person对Person.prototype有隐式引用(__proto__)</span></span><br><span class="line"><span class="comment">//Person对象又是由构造器Object创建</span></span><br><span class="line"><span class="comment">//所以Person对Object.prototype有隐式引用(__proto__)</span></span><br></pre></td></tr></table></figure><p><img src="/assets/blogImg/prototype.png" alt="原型"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要学好Js，首先必须得先理解原型(prototype)&lt;br&gt;why？&lt;br&gt;js作为面向对象的语言，实现面向对象的机制就是原型！&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="//vivi.fenghou.site/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>你真的学好Js了吗</title>
    <link href="//vivi.fenghou.site/2016/12/27/2016-12-27-%E4%BD%A0%E7%9C%9F%E7%9A%84%E5%AD%A6%E5%A5%BDJs/"/>
    <id>//vivi.fenghou.site/2016/12/27/2016-12-27-你真的学好Js/</id>
    <published>2016-12-27T11:08:58.000Z</published>
    <updated>2018-01-16T02:33:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我看来前端(Js)就好比是个剑客江湖<br>江湖中有人练react宝典，有人练vue神功<br>有人锻造webpack利剑<br>…<br><a id="more"></a><br>而Js就是这些的基础心法，决定这些宝典,神功最后在你手上的杀伤力<br>那么作为最基础的心法，你真的参透的了吗？</p><blockquote><p>这里简单的记录些Js的一些特点</p></blockquote><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>什么是面向对象</p><blockquote><p>一切事物皆对象<br>对象具有封装和继承特性<br>对象与对象之间使用消息通信，各自存在信息隐藏</p></blockquote><p>众所周知Java采用面向对象思想构造其语言，它实现了类、继承、多态、接口等机制。<br>但是这些机制，只是实现面向对象编程的一种方式<br>实际上，Js是通过原型的方式来实现面向对象编程的<br>Js中的对象是依靠构造器(constructor)利用原型(prototype)构造出来的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象的声明</span></span><br><span class="line"><span class="comment">//字面式对象声明</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">'Louis'</span>,</span><br><span class="line">    age:<span class="string">'24'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用函数构造器构造对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name:<span class="string">'Louis'</span>,</span><br><span class="line">    age:<span class="string">'24'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//这里的new关键字跟java中 的new毫无关系</span></span><br><span class="line"><span class="comment">//只是借用了它的关键字new</span></span><br><span class="line"><span class="comment">//用来表示调用构造器创建对象</span></span><br></pre></td></tr></table></figure><h3 id="弱类型语言"><a href="#弱类型语言" class="headerlink" title="弱类型语言"></a>弱类型语言</h3><p>在Js中，定义变量不必声明其类型。但这不意味着变量没有类型。<br>原始类型：布尔型、数值型、字符串类型<br>引用类型：对象类型(数组是一种特殊的对象)、函数类型<br>其他类型：空类型和未定义类型<br>js中的变量可以根据所附的值改变类型<br>原始类型按值传送，在栈内存中存的是变量的值<br>引用类型则按引用传送，在栈内存中存的是 引用对象在堆内存中的地址<br>所以这里涉及到引用类型深拷贝和浅拷贝的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浅拷贝 把父对象的属性全部拷贝给子对象</span></span><br><span class="line"><span class="comment">//如果父元素的属性对应的值是引用类型，那子对象对应的属性的值还是引用类型的内存地址</span></span><br><span class="line"><span class="comment">//这个时候就需要深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">pre</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ch = pre.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> pre !== <span class="string">'object'</span>)&#123;</span><br><span class="line">            ch = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.JSON)&#123;</span><br><span class="line">            ch = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(pre))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> pre)&#123;</span><br><span class="line">                ch[i] = <span class="keyword">typeof</span> pre[i] === <span class="string">'object'</span> ?</span><br><span class="line">                (pre[i].constructor === <span class="built_in">Array</span> ? pre[i].slice() : deepCopy(pre[i]))</span><br><span class="line">                : pre[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数是一等对象"><a href="#函数是一等对象" class="headerlink" title="函数是一等对象"></a>函数是一等对象</h3><p>在JavaScript中，函数是一等对象<br>可以存储在变量中<br>可以作为参数传给其他函数<br>可以作为返回值从其他函数传出<br>还可以在运行时进行构造<br>可以用function(){…}这样的语法创建匿名函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line">    alert(foo*bar);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>这个函数在定义后便会立即执行<br>匿名函数可以用来创建闭包<br>闭包是一个受到保护的变量空间<br>由内嵌函数生成</p><h3 id="对象的易变性"><a href="#对象的易变性" class="headerlink" title="对象的易变性"></a>对象的易变性</h3><p>JavaScript中,一切都是对象<br>除了三种原始类型(布尔型、数值型、字符串类型)<br>即便是这几种类型在必要时候也会被自动封装成对象<br>而且所有对象都是易变的(mutable)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为函数添加属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispalyError</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    dispalyError.numTimesExecuted++;</span><br><span class="line">    alert(message);</span><br><span class="line">&#125;</span><br><span class="line">dispalyError.numTimesExecuted = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//对定义的类和实例化的对象进行修改</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    getAge:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> alice = <span class="keyword">new</span> Person(<span class="string">'Alice'</span>,<span class="number">39</span>);</span><br><span class="line"><span class="keyword">var</span> bill = <span class="keyword">new</span> Person(<span class="string">'Bill'</span>,<span class="number">20</span>);</span><br><span class="line">Person.prototype.getGreeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hi '</span>+ <span class="keyword">this</span>.getName()+<span class="string">'!'</span>;</span><br><span class="line">&#125;</span><br><span class="line">alice.displayGreeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.getGreeting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承在JavaScript中不像在别的面向对象语言中那样简单<br>JavaScript使用的是基于对象的继承<br>它也可以用来模仿基于类的继承<br>Es6中新增了extends实现继承<br>后面会有文章相信讲讲继承</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我看来前端(Js)就好比是个剑客江湖&lt;br&gt;江湖中有人练react宝典，有人练vue神功&lt;br&gt;有人锻造webpack利剑&lt;br&gt;…&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="//vivi.fenghou.site/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>1px != 1px -- 移动端适配浅析</title>
    <link href="//vivi.fenghou.site/2016/12/19/2016-12-19-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    <id>//vivi.fenghou.site/2016/12/19/2016-12-19-移动端适配/</id>
    <published>2016-12-19T11:06:45.000Z</published>
    <updated>2018-01-16T02:33:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/rem-dpr.png" alt="px"><br><a id="more"></a></p><p>css中我们一般使用px作为单位<br>在pc上css中的1个像素往往对应着电脑屏幕中的1个物理像素<br>这可能会给我们造成一个错觉<br>css中的像素等于设备的物理像素<br>但实际情况却并非如此<br>css中的像素只是一个抽象的单位<br>在不同的设备或不同的环境中<br>css中的1px所代表的设备物理像素是不同的</p><p>典型的就是retina屏</p><p>首先我们先了解几个概念</p><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p>viewport 是用户网页的可视区域<br>pc中就是屏幕宽度<br>移动设备中viewport(这个虚拟窗口)比屏幕宽 一般为980</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">移动端布局viewport的宽度设为理想宽度</span><br><span class="line">layout viewport 默认的viewport 比屏幕宽 <span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line">visual viewport  浏览器可视区域的大小 <span class="built_in">window</span>.innerWidth</span><br><span class="line">ideal viewport 最适合移动设备的viewport</span><br><span class="line">width：控制 viewport 的大小，可以指定的一个值，如果 <span class="number">600</span>，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 <span class="number">100</span>% 时的 CSS 的像素）。</span><br><span class="line">height：和 width 相对应，指定高度。</span><br><span class="line">initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</span><br><span class="line">maximum-scale：允许用户缩放到的最大比例。</span><br><span class="line">minimum-scale：允许用户缩放到的最小比例。</span><br><span class="line">user-scalable：用户是否可以手动缩放。</span><br></pre></td></tr></table></figure><h3 id="物理像素-physical-pixel"><a href="#物理像素-physical-pixel" class="headerlink" title="物理像素(physical pixel)"></a>物理像素(physical pixel)</h3><p>一个物理像素是显示器(手机屏幕)上最小的物理显示单元<br>在操作系统的调度下<br>每一个设备像素都有自己的颜色值和亮度值。</p><h3 id="设备独立像素-density-independent-pixel"><a href="#设备独立像素-density-independent-pixel" class="headerlink" title="设备独立像素(density-independent pixel)"></a>设备独立像素(density-independent pixel)</h3><p>设备独立像素(也叫密度无关像素)<br>可以认为是计算机坐标系统中得一个点<br>这个点代表一个可以由程序使用的虚拟像素(比如: css像素)<br>简单点就是屏幕宽高</p><h3 id="设备像素比-device-pixel-ratio"><a href="#设备像素比-device-pixel-ratio" class="headerlink" title="设备像素比(device pixel ratio)"></a>设备像素比(device pixel ratio)</h3><p>设备像素比 ＝ 物理像素 / 设备独立像素<br>5,6的dpr=2，1个css像素等于2个物理像素<br>6p的dpr=3,1个css像素等于3个物理像素</p><p>那首先我们在移动端布局，viewport肯定不能是默认的值<br>最终viewport宽度等于应该等于设备的宽度<br>我们的布局视图应该是 按照物理像素来布局<br>设备独立像素可获得<br>设备像素比 window.devicePixelRatio<br>现在假设 在iphone6上布局</p><p>此时dpr = 2,<br>dip = 375<br>物理像素应该是 dpr * dip = 750<br>div{<br>border-top:1px solid #000;<br>}<br>现在在页面上要实现一个1px的上边框<br>由于移动端布局viewport缩成设备宽度<br>而分辨率没有变<br>所以这时的1px会有2px的效果</p><p>这个时候可以手动将viewport 宽度设成物理像素的宽度，然后将整个页面缩小 dpr 倍</p><p>1px 的问题解决了，那如何解决在不同手机显示设计稿中的一个100x100的div<br>设计稿 750<br>其中div 100x100<br>750的设计稿对应的是iPhone6<br>结合上面viewport的缩放<br>div{<br>width:100px;<br>height:100px;<br>}<br>在6上跟设计稿是完全相同的<br>而在5(640)上会变大</p><p>这个时候可以通过rem在不同设备上动态计算出比例值</p><p>假设在750设计稿中 1rem = 100px<br>那么在640设计稿中 1rem = 640/750*100px<br>此时1rem 不管在5上还是6上显示都完全跟在设计稿中显示效果相同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//html</span></span><br><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line"><span class="comment">//动态计算rem</span></span><br><span class="line"><span class="keyword">var</span> domDocEL = <span class="built_in">window</span>.document.documentElement,</span><br><span class="line">    mateViewPort = <span class="built_in">window</span>.document.querySelector(<span class="string">'meta[name="viewport"]'</span>),</span><br><span class="line">    nBasePsdWidth = <span class="number">750</span> / <span class="number">100</span>,</span><br><span class="line">    nDpr = <span class="built_in">window</span>.devicePixelRatio,</span><br><span class="line">    nScale = <span class="number">1</span> / nDpr,</span><br><span class="line">    nLayout = domDocEL.clientWidth,</span><br><span class="line">    nRem = nLayout * nDpr / nBasePsdWidth;</span><br><span class="line">domDocEL.style.fontSize = rem +<span class="string">'px'</span>;</span><br><span class="line">mateViewPort.setAttribute(<span class="string">'content'</span>,<span class="string">'width='</span>+nDpr*nLayout+<span class="string">',initial-scale='</span>+nScale+<span class="string">',maximum-scale='</span>+nScale+<span class="string">',minimum-scale='</span>+nScale+<span class="string">',user-scalable=no'</span>);</span><br></pre></td></tr></table></figure><p>对于字体可以用写个mixin方法<br>根据不同的dpr设置字号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin px2rem($name,$px) &#123;</span><br><span class="line">   [data-dpr=<span class="string">"2"</span>] &amp; &#123;</span><br><span class="line">     #&#123;$name&#125;: $px*2/2+px;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>移动端布局将viewport设成物理像素的大小,然后在缩放为dpr的倒数倍。<br>dpr不存在？<br>简单点~~~<br>那就指定为1！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/rem-dpr.png&quot; alt=&quot;px&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="//vivi.fenghou.site/tags/css/"/>
    
      <category term="rem" scheme="//vivi.fenghou.site/tags/rem/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown语法</title>
    <link href="//vivi.fenghou.site/2016/12/12/2016-12-12-md-rule/"/>
    <id>//vivi.fenghou.site/2016/12/12/2016-12-12-md-rule/</id>
    <published>2016-12-12T02:25:27.000Z</published>
    <updated>2018-01-16T02:33:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>markdown 部分语法<br><a id="more"></a></p><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p><code>亮不亮</code></p><p><a href="http://blog.csdn.net/guodongxiaren" title="悬停显示" target="_blank" rel="noopener">我的博客</a></p><ul><li>ES<ul><li>JS<ul><li>JS1</li></ul></li></ul></li></ul><blockquote><p>数据结构</p><blockquote><p>树</p><blockquote><p>二叉树</p><blockquote><p>平衡二叉树</p><blockquote><p>满二叉树</p></blockquote></blockquote></blockquote></blockquote></blockquote><table><thead><tr><th>第一格表头</th><th>第二格表头</th></tr></thead><tbody><tr><td>内容单元格 第一列第一格</td><td>内容单元格第二列第一格</td></tr><tr><td>内容单元格 第一列第二格 多加文字</td><td>内容单元格第二列第二格</td></tr></tbody></table><p>加删除线像这样用： <del>删除这些</del></p><ul><li>[x] 支持 @提到某人、#引用、<a href="">链接</a>、<strong>格式化</strong> 和 <del>标签</del> 等语法</li><li>[x] 需要使用列表语法来激活（无序或有序列表均可）</li><li>[x] 这是一个已完成项目</li><li>[ ] 这是一个未完成项目</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;markdown 部分语法&lt;br&gt;
    
    </summary>
    
    
      <category term="markdown" scheme="//vivi.fenghou.site/tags/markdown/"/>
    
  </entry>
  
</feed>
